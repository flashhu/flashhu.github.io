---
layout:     post
title:      "Head First Java"
subtitle:   "Java入门"
date:       2019-12-21 15:33:57
author:     "虎鲸"
header-img: "img/post-bg-head-java.jpg"
tags:
    - 书摘
    - Java
---

#### 基本概念

* 类存于源文件里，方法存于类中，语句存于方法中
* Java中的integer与boolean两种类型并不相容

```java
//错误示范
int x = 1;
while (x) { }

//正确示范
boolean isHot = true
while (isHot) { }
```

***

#### 类与对象

* 覆盖的意思是由子类重新定义继承下来的方法，以改变或延伸此方法的行为
* 对象是靠类的模型塑造出来的；类是对象的蓝图
* 对象本身已知的事物被称为实例变量；对象可以执行的动作称为方法

* 面向对象的应用程序中，`main( )`的两种用途为测试真正的类，启动Java应用程序
* 当对象被创建时，它会被存放在堆的内存区域中（可回收）。Java会根据对象的大小分配空间
* 任何变量只要加上public、static、和final，基本上都会变成全局变量取用的常数

| 名词     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 类       | 由`.java`文件编译出来；功能类似模板；能申明方法<br/>有很多方法；拥有很多行为；被用来创建对象实例； |
| 对象     | 实例变量值可以与其他兄弟姐妹不同；执行工作；有很多方法；有很多行为；生存于堆上；状态可以改变；可以在运行期变化 |
| 方法     | 执行工作；待在对象中                                         |
| 实例变量 | 代表“状态”；待在对象中；状态可以改变；可以在运行期中变化     |

***

#### primitive主数据类型和引用

* 变量必须拥有类型和名称
* boolean类型的位数由 Java虚拟机决定
* `primitive` 主数据类型包括：`boolean`, `char`, `byte`, `short`, `int`, `long`, `float`, `double`
* `primitive`主数据类型变量是以字节来代表实际的变量值；对象引用变量是以字节来表示取得对象的方法
* 创建对象实例时，对象本身并没有放进变量中。对引用变量来说，变量值是取得特定对象的位表示法
* 对于任意一个 Java 虚拟机来说，所有的引用大小都一样，但不同的 Java 虚拟机间可能会以不同的方式来表示引用
* 在 Java 中，不可以对引用变量进行运算
* 数组是个对象，不管里面放的是不是 `primitive` 主数据类型
* 没有引用到任何对象的引用变量的值为 `null` 值

***

#### 方法操作实例变量

* 任一类的每个实例都带有相同的方法，但是方法可以根据实例变量的值来表现不同的行为
* 方法会运用形参，调用的一方会传入实参。实参是传给方法的值，当它传入方法后，就成了形参
* Java是通过值传递的，也就是说通过拷贝传递的。方法无法改变调用方所传入的参数
* 引用对象的变量所携带的是远程控制而不是对象本身。若对方法传入参数，实际上传入的是远程控制的拷贝
* 传入与传出方法的值类型可以隐含的放大或是明确的缩小
* 封装的基本原则：将实例变量标记为私有的 并提供公有的getter与settter来控制存取动作
* 实例变量是声明在类内而不是方法中；局部变量是声明在方法中
* 实例变量有默认值；局部变量没有默认值，在使用前必须初始化

| 实例变量        | 默认值 |
| --------------- | ------ |
| integers        | 0      |
| floating points | 0.0    |
| booleans        | false  |
| references      | null   |

* `==`比较两个`primitive`主数据类型，或判断两个引用是否引用同一个对象

  equals()`来判断两个对象是否在意义上相等

***

#### Java API

* ArrayList 是个 Java API 的类

| ArrayList                                                    | 数组                                                        |
| ------------------------------------------------------------ | ----------------------------------------------------------- |
| 自动调整大小                                                 | 创建时必须确定大小                                          |
| 存放对象时可以不指定位置<br>myList.add(Int, Object)          | 存放对象时必须指定位置，且不能超出已确定的大小<br>myList[1] |
| 参数化类型<br>ArrayList<String\><br>只能携带对象而不是 `primitive` 主数据类型 | ---                                                         |

* 除了 `java.lang` 之外，使用到其他包的类都需要指定全名
* 运用 `import` 只是省下每个类前面的包名称，程序不会因为用了 `import` 而变大或变慢

***

#### 运算符

* 短运算符（&&， ||）左右两边都符合时才为`true`。但当 Java 虚拟机发现左方的表达式已经能得出结果时，不会再计算右方表达式
* 长运算符（&， |）在`boolean`表达式时会强制 Java 虚拟机一定要计算运算符两边的算式。`&`, `|`通常是用来作位的运算

***

#### 继承与多态

* 覆盖的意思是由子类重新定义继承下来的方法以改变或延伸此方法的行为
* 当某个方法在子类中被覆盖过，调用这个方法时会调用到覆盖过的版本
* “IS-A” 测试适用在继承层次的任何地方。如果类B是继承类A，且类B是类C的父类，则C应该能通过类IS-A A的测试
* 继承概念下的IS-A是个单向的关系。`X IS-A Y`隐喻着X可以做出任何Y可以做的事情
* 子类不完全覆盖掉父类的功能，只是加上额外的行为，可以通过`super`关键字来取用父类

```java
public void roam() {
  super.roam();
  // my own roam stuff
}
```

* 父类可以通过存取权限决定子类是否能继承某些特定成员

   受权限限制程度从左往右递减

  `private` > `default` > `protected` > `public`

* `public`类型的成员会被继承；`private` 类型的成员不会被继承

* 在多态下，引用与对象可以是不同的类型，引用类型可以是实际对象类型的父类

* 三种防止某个类被作出子类的方法：

  ①存取控制：类不标记为公有。非公有的类只能被同一个包的类作子类

  ②使用`final`修饰符，表示是继承树的末端，不能被继承

  ③让类只拥有`private`的构造程序

* 防止特定的方法被覆盖，可以将该方法标识上`final`这个修饰符。将整个类标识成`final`表示没有任何方法可以被覆盖

* 方法的重载是指两个方法的名称相同，但参数不同。重载版的方法只是刚好有相同名字的不同方法，与继承或多态无关。重载的方法与覆盖方法不一样

* 重载方法的返回类型可以不同，不能只改变返回类型，可以更改存取权限

***

#### 接口与抽象类

* 抽象类不能创建任何类型的实例，具体的类是实际可以被初始化为对象的
* 设计抽象类时，在类的声明前加上抽象类的关键词`abstract`
* 抽象类除了被继承过之外，是没有用途，没有值，没有目的的
* 如果声明抽象方法，必须将类也标记为抽象的。非抽象类不能拥有抽象方法
* 抽象方法的意义是就算无法实现出方法的内容，但还是可以定义出一组子型共同的协议
* 抽象的方法没有内容，它的声明以分号结束
* 抽象类可以带有抽象和非抽象的方法
* `Object`类是所有类的源头，是所有类的父类
* `Object`类没有必须被覆盖过的方法，至少不是正式的 Java抽象类
* `Object`类的两个主要目的：作为多态让可以应付多种类型的机制，以及提供 Java 在执行期对任何对象都有需要的方法的实现程序代码，有一些部分的方法与线程有关
* 任何从 `ArrayList<Object>` 取出的东西都会被当做 `Object` 类型的引用而不管他原来是什么
* 编译器是根据引用类型来判断有哪些method可以调用，而不是根据`Object`确实的类型
* 转换回原来的类型

​       法一：确定引用类型

```java
Object o = al.get(index);
Dog d = (Dog) o; //类型转换
d.roam();
```
​      法二：不确定引用类型

​     使用`instanceof`运算符来检查，如类型转换有误，得到`ClassCastException`异常并且终止

```java
if(o instanceof Dog){
  Dog d = (Dog) o;
}
```

* Java 不允许多重继承
* 所有接口的方法都是抽象的

```java
//接口的定义
public interface Pet {....}

//接口的实现
public class Dog extends Canine implements Pet {....}


```

* 接口便于为不同的需求组合出不同的继承层次
* 不同的继承树的类也可以实现相同的接口，类可以实现多个接口
* 调用父类的方法，如果在子类中指定命令`super.runReport()`，父类的方法就会执行

***

#### 构造器与垃圾收集器

* 实例变量存在于所属的对象中；局部变量的生命周期只限于方法被放在栈上的这段期间（方法调用至执行完毕为止）
* 当调用方法时，该方法会被放在调用栈的栈顶
* 只有变量本身会放在栈上，对象本身只会存在于堆上
* 所有局部变量都存在于栈上相对应的堆栈块中
* 对象引用变量与`primitive`主数据类型变量都是放在栈上
* 实例变量存在于对象所属的堆空间上
* 如果实例变量全都是`primitive`主数据类型的，则 Java 会依据`primitive`主数据类型的大小为该实例变量留下空间
* 当新建对象的带有对象引用的变量时，Java 会留下空间给实际变量的值，但引用变量的值并不是对象本身。如有声明变量但没有给它赋值，则只会留下变量的空间，直到引用变量被赋值一个新的`Antenna`对象才会在堆上占有空间
* 构造函数必须与类同名且没有返回类型
* 唯一在构造函数以外调用构造函数的办法就是新建一个类。如没有自己写构造函数，编译器会自动生成。默认的构造函数是没有参数的
* 构造函数使得有机会可以介入`new`的过程
* Java 可以有与类同名的方法而不会变成构造函数。其差别在于是否有返回类型。构造函数不会有返回类型
* 构造函数不会被继承
* 重载构造函数的意思代表你有一个以上的构造函数且参数不同
* 如果自己已经写了一个有参数的构造函数，并需要一个没有参数的构造函数，则必须自己手动写
* 最好能有无参数的构造函数让人可以选择使用默认值
* 构造函数可以是公有，私有或不指定的
* 在创建新对象时，所有继承下来的构造函数都会被执行
* 抽象类也有构造函数
* 在构造函数中用`super`调用父类的构造函数的部分

![图例](/img/in-post/head-first-java/sample1.png)

* 调用父类构造函数唯一方法是调用`super()`

  ```java
  public Duck(int newSize){
    super();
    size =  newSize;
  }
  ```

* 如自己没有调用`super()，编译器会对每个重载版本的构造函数加上`super()`，编译器加的一定是没有参数的版本

* 父类的构造函数必须在子类的构造函数之前结束

* 对`super()`的调用必须是构造函数的第一个语句

* 每个构造函数可以选择调用`super()`或`this()，但是不能同时调用`

* 使用`this()`来从某个构造函数调用同一个类的另外一个构造函数。`this()`只能用在构造函数中，且必须是第一行语句

* 局部变量只会存活在声明该变量的方法中；实例变量的寿命与对象相同，如果对象还活着，则实例变量也会是活的

  ![图例](/img/in-post/head-first-java/sample2.png)

* 只要有活着的引用，对象也就会活着。如果某个对象的引用已经不在它范围中。但此引用还是活着的，则此对象就会继续活在堆上

* 释放对象引用的方法：

  ①引用永久性的离开它的范围 ②引用被赋值到其他的对象上 ③直接将引用设定为`null`

* 对`null`引用使用圆点运算符会在执行期遇到`NullPointerException`这样的错误

***

#### 数字与静态

* 在 Math 这个类中的所有方法都不需要实例变量值。因为这些方法都是静态的，所以无需 Math 实例， 会用到的只有类本身
* `static`这个关键词可以标记出不需要类实例的方法。一个静态的方法代表说"一种不依靠实例变量也就不需要对象的行为"
* 以类的名字调用静态的方法；以引用变量的名称调用非静态的方法
* 带有静态的方法的类通常不打算要被初始化
* 任何非静态的方法都代表必须以某种实例来操作
* 静态的方法不能调用非静态的变量，也不能调用非静态的方法
* 静态的方法是不知道堆上有哪些实例的
* 静态变量是被同类的所有实例共享的变量
* 每个实例一个实例变量；每个类一个静态变量
* 静态变量是共享的。同一类所有的实例共享一份静态变量
* 静态变量会在该类的任何静态方法执行之前就初始化
* 如没有给静态变量赋初值，它就会被设定为默认值，就像实例变量所被赋予的默认值一样
* 一个被标记为`final`的变量代表它一旦被初始化之后就不会改变
* 识别变量为不变的常数 `public  static final`
* 常数变量名称应该要都是大写字母
* 静态初始化程序是一段在加载类时会执行的程序代码，它会在其他程序可以使用该类之前就执行，所以很适合放静态`finnal`变量的起始程序

```java
class Foo {
  final static int x;
  static {
    x = 42;     
  }
}
```

* 静态`final`变量的初始化：

①声明的时候

```java
public class Foo {
  public static final int FOO_X = 25；
}
```

②在静态初始化程序中

```java
public class Bar {
  public static final double BAR_SIGN;
    
  static {
    BAR_SIGN = (double) Math.random();      
  }
}
```

* `final`关键词来修饰非静态的变量，包括了实例变量，局部变量，甚至是方法的参数
* `final`的变量代表你不能改变它的值；`final`的方法代表你不能覆盖该方法；`final`的类代表你不能继承该类
* 非静态方法不可以调用该类静态的方法或静态的变量
* 将类标记为`final`的主要目的是为了安全

* 如果一个类不能被子类化，则它的方法根本就无法被覆盖。如果只是想限制部分的方法不能被覆盖，那就单独地标记为`final`