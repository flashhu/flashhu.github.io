# 认证

[傻傻分不清之 Cookie、Session、Token、JWT](https://juejin.cn/post/6844904034181070861)

[[译]每个人都可以理解的授权访问和身份认证](https://juejin.cn/post/6935230984619032589/)

[OAuth 2.0 的一个简单解释](http://www.ruanyifeng.com/blog/2019/04/oauth_design.html)

[OAuth 2.0 的四种方式](http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html)



选择方案时：

1. 是否支持跨域（是否使用 Cookie）
2. 有没有加密（存秘密数据可靠吗）
3. 承担了什么功能：认证，授权，交换信息
4. 服务端是否需要存数据（签发后是否能再修改）
5. 有效期设置，是否可信



## 相关概念

**认证** (authentication) ：验证当前用户的身份

**授权** (authorization)：授予访问资源的权限，如 cookie、session、token、OAuth

***

> HTTP 是无状态的，需要借助 Cookie 或 Session 实现有状态的效果

## Cookie

* 存储在客户端
* 不可跨域，一级域名和二级域名之间允许共享
* 可能被篡改，使用前需要验证
* 避免存储敏感信息
* 浏览器对一网站的 Cookie 数量有限制
* 移动端支持较差

| 属性           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| **name=value** | 键值对，设置 Cookie 的名称及相对应的值，都必须是**字符串类型** - 如果值为 Unicode 字符，需要为字符编码。 - 如果值为二进制数据，则需要使用 BASE64 编码。 |
| **domain**     | 指定 cookie 所属域名，默认是当前域名                         |
| **path**       | **指定 cookie 在哪个路径（路由）下生效，默认是 '/'**。 如果设置为 `/abc`，则只有 `/abc` 下的路由可以访问到该 cookie，如：`/abc/read`。 |
| **maxAge**     | cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。 - **比 expires 好用**。 |
| **expires**    | 过期时间，在设置的某个时间点后该 cookie 就会失效。 一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除 |
| **secure**     | 该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。 |
| **httpOnly**   | **如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全** |
| **SameSite**   | 允许服务器要求某个 cookie 在跨站请求时不会被发送，从而阻止 CSRF。`None`**。**浏览器会在同站请求、跨站请求下继续发送 cookies，不区分大小写。**`Strict`。**浏览器将只在访问相同站点时发送 cookie |

## Session

* 存储在服务端，容易占过多服务器资源，需要及时清理
* 基于 cookie，sessionId 存储在客户端的 cookie 中。可能被禁止使用 cookie
* 集群部署时，存在服务器 session 共享问题

![图例](https://user-gold-cdn.xitu.io/2019/12/29/16f523a04d0b3cf5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### Cookie 和 Session 的区别

- **安全性：** Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。
- **存取值的类型不同**：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。
- **有效期不同：** Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。
- **存储大小不同：** 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。

***

## Token

> 服务端无状态

* 由服务端生成，可能包含用户 id，时间戳，签名等信息，发给客户端保存
* 请求时携带 Token
* 服务端无状态化、可扩展性好
* 支持移动端设备
* 安全
* 支持跨程序调用
* 使用双令牌实现无感知登录
  * Refresh Token 过期时间设置较长，用于更新 Access Token 的有效期
  * Access Token 过期时间设置较短

![图例](https://user-gold-cdn.xitu.io/2019/12/29/16f523a04d1c887b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



### Token 和 Session 的区别

- Session 是一种**记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息**。
- 而 Token 是**令牌**，**访问资源接口（API）时所需要的资源凭证**。Token **使服务端无状态化，不会存储会话信息。**
- Session 和 Token **并不矛盾**，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。**如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。**
- 所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 **认证 和 授权** ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的**认证**，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：**如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。**



## JWT

- JSON Web Token（简称 JWT）是目前最流行的**跨域认证**解决方案。
- 是一种**认证授权机制**
- JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。
- 可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名
- 请求时可存在 header 中的 Authorization
- 服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为
- 因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要
- 因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）
- 因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制
- **一旦签发，到期前始终有效**，除非存在额外逻辑

![图例](https://user-gold-cdn.xitu.io/2019/12/29/16f523a04e881087?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



### Token 和 JWT 的区别  

**相同：**

- 都是访问资源的令牌
- 都可以记录用户的信息
- 都是使服务端无状态化
- 都是只有验证成功后，客户端才能访问服务端上受保护的资源

**区别：**

- Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。
- JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。



## OAuth 2.0

### 发展历程

**1. 共享登录凭证**

方式：在软件 A 上输入软件 B 的登录凭证

弊端：

① **账号安全性** => 软件 A 未合理保管（A 会保存账号密码），易发生盗号情况 

② **暴露过多权限** => 软件 A 拥有对软件 B 上账号的访问权限，用户只有修改密码才能收回授权

**2. OAuth**

> 一种**授权**机制，直接用来做身份验证是有风险的

方式：软件 A 先在软件 B 中备案，软件 A 要求用户授权，用户同意后，向认证服务器申请令牌，使用令牌获取相关资源

关键：如何发放令牌

优点：

① 不暴露登录凭证，主要使用颁布令牌授予第三方软件权限

② 具有可控性：有效时间，可撤销，权限范围

弊端：

①  混合代理问题：冒用其他用户令牌；冒用其他第三方软件获取的令牌

### OAuth 上进行身份认证

>  [OpenID 连接](https://openid.net/specs) 是一个**基于 OAuth 2.0** 的规范，它规定了如何认证用户的身份

* 由第三方服务提供 ID 令牌
* ID 令牌格式固定
  * 头字段：包含有签名算法和令牌类型的 JSON 对象
  * 载荷段：声明了关于用户和身份认证事件的字段
  * 加密段：签名
  * 身份认证字段
    * `iss` **（发行人）**：JWT 的发行者，例如授权访问服务器。
    * `aud` **（接收者）**：JWT 的目标接收者；对于 ID 令牌来说，这个字段一定是接收令牌的应用的 ID。
    * `exp` **（过期时间）**：过期时间；在此时间之后 ID 令牌不再有效。
    * `iat` **（发行时间）**：ID 令牌发行的时间。
  * 身份字段：用户信息

