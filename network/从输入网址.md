# 从输入URL到页面展示，发生了什么

[浏览器工作原理与实践 | 导航流程：从输入URL到页面展示，这中间发生了什么？](https://time.geekbang.org/column/article/117637)

[浏览器工作原理与实践 | 渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？](https://time.geekbang.org/column/article/118205)

[浏览器工作原理与实践 | 渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？](https://time.geekbang.org/column/article/118826)

[从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！](https://juejin.cn/post/6844903576284692494)

[透视 HTTP 协议 | 键入网址再按下回车，后面究竟发生了什么？](https://time.geekbang.org/column/article/100502)



## 概要

主要由三个进程相互配合完成：

* **浏览器进程**主要负责用户交互、子进程管理和文件储存等功能

* **网络进程**是面向渲染进程和浏览器进程等提供网络下载功能

* **渲染进程**的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全。

这一过程大致可以描述为：

* 首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。

* 然后，在网络进程中发起真正的 URL 请求。接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。

* 浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程；

* 渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道；

* 最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。

* 浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。

![流程示意图](../image/network/从输入URL完整流程.png)

***

## 详细过程

### 1. 用户输入

> 浏览器进程

① 判断查询关键字为搜索内容还是请求的 URL

② 当前页面执行 `beforeunload` 事件，如询问是否确认离开，表单尚未保存等，可在此时取消导航，不再继续处理

③ 当前页面没有立即被替换，先进入加载状态

### 2. URL 请求

> 浏览器进程通过进程间通信（IPC）将 URL 发送至**网络进程**

> 用户发出 URL 请求到页面开始解析的这个过程，就叫做**导航**

① 查找本地资源是否已缓存该资源，如已缓存，则直接返回给浏览器进程 => [内存缓存/强缓存](network/基础?id=_7-浏览器缓存)

② 进行 DNS 解析，获取 IP 地址 => [DNS过程](network/基础?id=dns-查询过程)

③ TCP 三次握手建立连接

④ 如果请求协议为 HTTPS，还要进行 TLS 四次握手建立连接

⑤ 构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息

⑥ 服务端收到请求信息后，根据请求生成响应信息，并发给网络进程

⑦ 解析响应头中的内容，如状态码为 301 或 302，根据响应首部字段 Location 获取重定向地址，重新发起 HTTP 或 HTTPS 请求

⑧ 根据实体首部字段 Content-Type，了解数据类型，决定如何显示响应体内容。如为 `application/octet-stream`，则会按下载类型处理，会将请求提交到浏览器的下载管理器，不再继续处理。如为 `text/html` ，则会继续导航流程

### 3. 提交文档

> 默认情况下，Chrome 会为每个页面分配一个渲染进程
>
> 如为同一站点，即根域名及协议一致，则会复用同一渲染进程

① 浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息

② 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”

③ 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程

④ 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。结束导航流程，进入渲染

### 4. 渲染阶段

![图例](https://static001.geekbang.org/resource/image/92/e8/9259f8732ddad472e5e08a633ad46de8.png)

> 流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成
>
> 每个阶段关注三个部分：输入，处理过程，输出

#### 构建 DOM 树

HTML 文件经 HTML 解析器解析，生成 [DOM](language/HTML?id=_8-什么是-dom) 树

#### 样式计算

① 将 CSS 文本转为样式表( styleSheets)

② 转换样式表中的属性值，使其标准化，如将 `em` 转为 `px`，将颜色转为 rgb 表示等

③ 结合 CSS [继承和层叠](language/CSS)规则，计算 DOM 树每个节点的样式属性，保存在 ComputedStyle 中

#### 布局阶段

> 计算出 DOM 树中可见元素的几何位置

① 遍历 DOM 树中的所有可见节点，构建一棵只包含可见元素的布局树

② 计算布局树节点的坐标位置，并写入布局树

#### 分层

对布局树进行分层，构建图层树。

如节点无对应图层，则从属于父节点所在图层，当元素拥有层叠上下文属性，或使用 `overflow` 出现裁剪、滚动等情况，会创建一图层

#### 绘制

根据图层树，依次对每个图层进行绘制。会拆分成多个小的绘制指令，按顺序组成待绘制列表。渲染主线程将待绘制列表提交给合成线程

#### 分块

为防止开销过大，合成线程会将图层划分为图块。

合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。

#### 栅格化

> 图块是栅格化执行的最小单位

栅格化指将图块转换为位图。

渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。

栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。

#### 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命——“DrawQuad”，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

![完全的渲染流程](https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png)

## 相关概念

[浏览器重绘(repaint)重排(reflow)与优化[浏览器机制]](https://juejin.cn/post/6844903745914929165)

### 1. 重排

![重排图例](https://static001.geekbang.org/resource/image/b3/e5/b3ed565230fe4f5c1886304a8ff754e5.png)

* 更新元素的几何属性（宽，高等）
* 触发重新布局，开销最大

### 2. 重绘

![重绘图例](https://static001.geekbang.org/resource/image/3c/03/3c1b7310648cccbf6aa4a42ad0202b03.png)

* 更新元素绘制属性（如颜色）
* 直接进入绘制，省去布局和分层，执行效率比重排高

### 3. 合成

![合成图例](https://static001.geekbang.org/resource/image/02/2c/024bf6c83b8146d267f476555d953a2c.png)

* 修改不需要布局也不需要绘制的属性
* 相比重排和重绘，效率大大提升